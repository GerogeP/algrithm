查找一个数
算法描述：

先从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；
如果目标元素大于中间元素，则在数组大于中间元素的那一半中查找，而且跟开始一样从 中间元素开始比较。
如果目标元素小于中间元素，则在数组小于中间元素的那一半中查找，而且跟开始一样从 中间元素开始比较。
如果在某一步骤数组为空，则代表找不到。
复杂度分析

平均时间复杂度： 
最坏时间复杂度： 
最优时间复杂度： 
空间复杂度
迭代: 
递归： 
（无尾调用消除）
后面的复杂度也是类似的，不再赘述。

这种搜索算法每一次比较都使搜索范围缩小一半，是典型的二分查找。

这个是二分查找中最简答的一种类型了，我们先来搞定它。 我们来一个具体的例子， 这样 方便大家增加代入感。假设 nums 为 [1,3,4,6,7,8,10,13,14]， target 为 4·。

刚开始数组中间的元素为 7
7 > 4 ，由于 7 右边的数字都大于 7 ，因此不可能是答案。我们将范围缩写到了 7 的 左侧。
此时中间元素为 3
3 < 4，由于 3 左边的数字都小于 3 ，因此不可能是答案。我们将范围缩写到了 3 的右 侧。
此时中间元素为 4，正好是我们要找的，返回其索引 2 即可。
如何将上面的算法转换为容易理解的可执行代码呢？就算是这样一个简简单单，朴实无华的 二分查找， 不同的人写出来的差别也是很大的。 如果没有一个思维框架指导你，那么你在 不同的时间可能会写出差异很大的代码。这样的话，你犯错的几率会大大增加。

这里给大家介绍一个我经常使用的思维框架和代码模板。

思维框架
** 首先定义搜索区间为 [left, right]，注意是左右都闭合，之后会用到这个点 **

你可以定义别的搜索区间形式，不过后面的代码也相应要调整，感兴趣的可以试试别的搜 索区间。

由于定义的搜索区间为 [left, right]，因此当 left <= right 的时候，搜索区间都不 为空，此时我们都需要继续搜索。 也就是说终止搜索条件应该为 left <= right。
举个例子容易明白一点。 比如对于区间 [4,4]，其包含了一个元素 4，因此搜索区间不 为空，需要继续搜索（试想 4 恰好是我们要找的 target，如果不继续搜索， 会错过正 确答案）。而当搜索区间为 [left, right) 的时候，同样对于 [4,4]，这个时候搜索区 间却是空的，因为这样的一个区间不存在任何数字·。

循环体内，我们不断计算 mid ，并将 nums[mid] 与 目标值比对。
如果 nums[mid] 等于目标值， 则提前返回 mid（只需要找到一个满足条件的即可）
如果 nums[mid] 小于目标值， 说明目标值在 mid 右侧，这个时候搜索区间可缩小为 [mid + 1, right] （mid 以及 mid 左侧的数字被我们排除在外）
如果 nums[mid] 大于目标值， 说明目标值在 mid 左侧，这个时候搜索区间可缩小为 [left, mid - 1] （mid 以及 mid 右侧的数字被我们排除在外）
循环结束都没有找到，则说明找不到，返回 -1 表示未找到。

